sigaction struct - funktion


PARSING

Input processing
> input from readline()
> implementation of working history (add_history)

LEXER/TOKENIZER
> converting input to string of tokens
> correct handling of white spaces

QUOTES HANDLING
> single quotes: metasignals (variables e.g. $VAR) not gonna be interpreted
> dqoutes: metasignals are not gonna be interpreted except $VAR
> 

OPERATIONEN
> recognizing pipes & redirections (<, >, <<, >>)
	- '<' redirect in
	- '>' redirect out
	- '>>' append
	- '<<' heredoc

VARIABLEN-EXPANSIONS
> replacing $VAR with substitutional value
> replacing $? with exit status of last cmd
> no expansion in single quite

SYNTAX-CHECKING & ERRORHADNLING
> empty cmds behind pipes/redirections
> if nothing standing before or behind redirection 
> incorrect placements of pipes

PARSER / COMMADN STRUCTURE
> correctly recognizing tokens
> distinction between built-ins and cmds
> correctly assigning redericts to correct cmds or file
> correctly assigning pipelines 
> creating data-structure for execution

else if (line\[i\] == '\\'') // Wenn ein Single Quote gefunden wird { ws = ++i; // Springe hinter das Ã¶ffnende Single Quote und speichere die Startposition while (line\[i\] && line\[i\] != '\\'') // Suche nach dem schlieÃŸenden Single Quote { i++; } if (line\[i\] == '\\'') // Falls ein schlieÃŸendes Single Quote gefunden wurde { // Extrahiere den Inhalt zwischen den Single Quotes word = ft\_strndup(line + ws, i - ws); // Speichere den Inhalt als Token (TOKEN\_WORD) error = create\_token(&tokens, TOKEN\_WORD, word); if (error < 0) { free(word); return (perror("ERROR:\\nTokenizing failed!\\n"), \-1); } // Gib den extrahierten Text zwischen den Quotes frei free(word); // Nach dem schlieÃŸenden Single Quote weiterfahren i++; } else // Falls kein schlieÃŸendes Single Quote gefunden wurde { printf("Error: Unmatched single quote!\\n"); return (\-1); // Fehler zurÃ¼ckgeben } }

das sieht schon mal relativ gut aus aber was ist mit dem Fall, dass man nur eine einzelne SIngle quote schreibt?

ChatGPT said:
Wenn eine einzelne Single Quote (') ohne passendes GegenstÃ¼ck existiert, entspricht das einem ungeÃ¶ffneten oder unvollstÃ¤ndigen String in Bash. Bash wartet dann darauf, dass der Nutzer die Eingabe vervollstÃ¤ndigt (z. B. durch eine neue Zeile).

ğŸ”¹ Was passiert in Bash bei einer einzelnen '?
Angenommen, du gibst Folgendes ein:

bash
Copy
Edit
echo 'Hello
Dann wartet Bash, bis du das schlieÃŸende ' eingibst. Das wird durch eine sekundÃ¤re Eingabeaufforderung (> ) signalisiert. Erst wenn die ' geschlossen wird, wird der gesamte String als ein einziges Token interpretiert.

Falls du wirklich eine einsame ' in einem Befehl haben mÃ¶chtest, musst du sie escapen oder anders schreiben:

bash
Copy
Edit
echo "'"
ğŸ”¹ Wie sollte unser Tokenizer darauf reagieren?
Wir mÃ¼ssen sicherstellen, dass:
âœ… Falls ein ' geÃ¶ffnet wird, aber kein passendes ' existiert, wir dies erkennen und eine passende Fehlermeldung ausgeben.
âœ… Falls ein ' geÃ¶ffnet und korrekt geschlossen wird, der Inhalt als ein einziges Token (TOKEN_WORD) gespeichert wird.
âœ… Falls eine ' einzeln steht, sollte sie nicht als separates Token gespeichert werden.

ğŸ›  Korrigierte Version fÃ¼r das Single-Quote-Handling
Hier ist die verbesserte Implementierung:

c
Copy
Edit
else if (line[i] == '\'') // Single Quote erkannt
{
    ws = ++i;  // Springe hinter das Ã¶ffnende Quote und speichere die Startposition

    while (line[i] && line[i] != '\'')  // Suche nach dem schlieÃŸenden Quote
    {
        i++;
    }

    if (line[i] == '\'')  // Falls ein schlieÃŸendes Quote gefunden wurde
    {
        // Extrahiere den Inhalt zwischen den Single Quotes
        word = ft_strndup(line + ws, i - ws);
        
        // Speichere den Inhalt als Token (TOKEN_WORD)
        error = create_token(&tokens, TOKEN_WORD, word);
        if (error < 0)
        {
            free(word);
            return (perror("ERROR:\nTokenizing failed!\n"), -1);
        }
        
        free(word); // Speicher freigeben
        
        i++; // Gehe Ã¼ber das schlieÃŸende Quote hinaus
    }
    else  // Falls kein schlieÃŸendes Single Quote gefunden wurde
    {
        printf("Error: Unmatched single quote detected! Waiting for closure...\n");
        return (-1);  // Fehler zurÃ¼ckgeben, da der String unvollstÃ¤ndig ist
    }
}
ğŸ”¹ Was passiert jetzt?
1ï¸âƒ£ VollstÃ¤ndige Quotes ('Hello <>!'):

Wird als ein einziges TOKEN_WORD gespeichert (also Hello <>!).

Die Quotes selbst werden nicht als Token gespeichert.

2ï¸âƒ£ UnvollstÃ¤ndige Quotes ('Hello ohne ' am Ende):

Gibt eine Fehlermeldung aus:

vbnet
Copy
Edit
Error: Unmatched single quote detected! Waiting for closure...
Tokenizing wird abgebrochen, bis eine vollstÃ¤ndige Eingabe gemacht wird.

3ï¸âƒ£ Einsame Single Quote ('):

Wird ebenfalls als Fehler behandelt, weil eine ' allein keinen gÃ¼ltigen String ergibt.

ğŸ›  Erweitern fÃ¼r Bash-Ã¤hnliches Verhalten?
Falls du mÃ¶chtest, dass dein Tokenizer wie Bash auf eine Fortsetzung wartet anstatt sofort einen Fehler zu werfen, kannst du eine neue Zeile einlesen, bis das ' geschlossen wird.

Hier ist eine Alternative, die Bashs Verhalten mit der PS2-Prompt-Simulation nachahmt:

c
Copy
Edit
else if (line[i] == '\'')
{
    ws = ++i;  
    while (line[i] && line[i] != '\'')
        i++;

    if (!line[i])  // Falls das Ende erreicht wurde, ohne ein schlieÃŸendes Quote
    {
        char *next_line = readline("> ");  // Bash-like Fortsetzung der Eingabe
        if (!next_line) 
        {
            printf("Error: Unexpected end of input\n");
            return (-1);
        }

        // FÃ¼ge neue Zeile zum aktuellen Token hinzu
        line = ft_strjoin(line, next_line);
        free(next_line);

        // Setze i zurÃ¼ck und suche weiter nach schlieÃŸendem Quote
        continue;
    }

    // Falls schlieÃŸendes Quote gefunden wurde, speichere den Inhalt
    word = ft_strndup(line + ws, i - ws);
    error = create_token(&tokens, TOKEN_WORD, word);
    free(word);
    i++;
}
ğŸ’¡ Was passiert hier?

Falls die ' nicht geschlossen wurde, wartet der Tokenizer auf eine weitere Eingabezeile, genau wie Bash es tun wÃ¼rde!

Das schlieÃŸt das ' nicht automatisch, sondern erlaubt dem Benutzer, weiterzuschreiben.

ğŸ”¹ Zusammenfassung
âœ”ï¸ Quotes werden nicht als separates Token gespeichert.
âœ”ï¸ UnvollstÃ¤ndige Quotes lÃ¶sen eine Fehlermeldung aus (oder fordern eine neue Eingabe, wenn du Bash-Ã¤hnliches Verhalten implementierst).
âœ”ï¸ Das Verhalten entspricht genau dem von Bash!

ğŸ”¹ NÃ¤chster Schritt: Falls du Double Quotes (") Ã¤hnlich behandeln mÃ¶chtest, kannst du fast denselben Code wiederverwenden! ğŸš€







You said:
continue;

kannst du die Funktion ohne continue schreiben?
ChatGPT said:
Ja, ich kann die Funktion so umschreiben, dass sie ohne continue funktioniert. Statt continue verwenden wir eine Schleife, die explizit nach einer geschlossenen ' sucht, bevor sie mit der Verarbeitung fortfÃ¤hrt.

Hier ist die Ã¼berarbeitete Version, die das gleiche Bash-Ã¤hnliche Verhalten beibehÃ¤lt, aber ohne continue:

Finale Version ohne continue
c
Copy
Edit
else if (line[i] == '\'')
{
    ws = ++i;  // Springe hinter das Ã¶ffnende Quote und speichere die Startposition

    while (1)  // Endlosschleife, um nach der schlieÃŸenden Quote zu suchen
    {
        while (line[i] && line[i] != '\'') // Suche nach schlieÃŸendem Quote
            i++;

        if (line[i] == '\'')  // Falls gefunden, Token speichern
        {
            word = ft_strndup(line + ws, i - ws);
            error = create_token(&tokens, TOKEN_WORD, word);
            free(word);
            i++;  // Gehe Ã¼ber das schlieÃŸende Quote hinaus
            break; // Beende die Schleife
        }

        // Falls kein schlieÃŸendes Quote vorhanden ist, neue Zeile einlesen
        char *next_line = readline("> ");
        if (!next_line) 
        {
            printf("Error: Unexpected end of input\n");
            return (-1);
        }

        // FÃ¼ge neue Zeile zum aktuellen Input hinzu
        char *temp = line;
        line = ft_strjoin(line, next_line); 
        free(temp);
        free(next_line);  
    }
}
ErklÃ¤rung der Ã„nderungen
ğŸ”¹ Anstelle von continue benutzen wir eine Endlosschleife (while (1)), die erst beendet wird, wenn:
1ï¸âƒ£ Ein schlieÃŸendes ' gefunden wurde (break;).
2ï¸âƒ£ Die Eingabe weitergefÃ¼hrt werden muss, weil die ' fehlt.

ğŸ”¹ Falls ein schlieÃŸendes Quote gefunden wird, wird der String als TOKEN_WORD gespeichert und die Schleife verlassen.
ğŸ”¹ Falls keines gefunden wird, wird eine neue Zeile eingelesen (readline("> ")), genau wie Bash es tut, und mit der neuen Zeile weitergesucht.
ğŸ”¹ Das Fehlermeldungssystem bleibt gleich: Falls keine neue Zeile eingelesen werden kann, gibt es einen Fehler fÃ¼r unvollstÃ¤ndige Eingaben.

âœ¨ Endergebnis:
âœ” Kein continue, aber identisches Verhalten zu Bash! âœ…




